diff --git a/gnpy/examples/sim_ex.py b/gnpy/examples/sim_ex.py
index 7ee1813..c5d49c0 100644
--- a/gnpy/examples/sim_ex.py
+++ b/gnpy/examples/sim_ex.py
@@ -1,25 +1,23 @@
-import matplotlib.pyplot as plt
-import networkx as nx
-import gnpy
-plt.rcdefaults()
+from gnpy import Network
+from gnpy.utils import read_config
+from os.path import realpath, join, dirname
 
-config_fn = './gnpy/examples/config/config_ex1.json'
-nw = gnpy.Network(config_fn)
-nw.propagate_all_paths()
+if __name__ == '__main__':
+    basedir = dirname(realpath(__file__))
+    filename = join(basedir, 'config/config_ex1.json')
+    config = read_config(filename)
 
-# output OSNR propagation
-for path in nw.tr_paths:
-    print(path.path)
-    for edge in path.edge_list:
-        print(edge, nw.g[edge[0]][edge[1]]['channels'])
+    nw = Network(config)
+    nw.propagate_all_paths()
 
-
-if 0:
-    layout = nx.spring_layout(nw.g)
-    nx.draw_networkx_nodes(nw.g, layout, node_size=1000,
-                           node_color='b', alpha=0.2)
-    nx.draw_networkx_labels(nw.g, layout)
-    nx.draw_networkx_edges(nw.g, layout, width=2,
-                           alpha=0.3, edge_color='green')
-    nx.draw_networkx_edge_labels(nw.g, layout, font_size=6)
-    plt.show()
+    # output OSNR propagation
+    for path in nw.tr_paths:
+        print(' → '.join(x.id for x in path.path))
+        for u, v in path.edge_list:
+            channels = nw.g[u][v]['channels']
+            channel_info = ('\n' + ' ' * 24).join(
+                '    '.join([ f'freq: {x["frequency"]:7.2f}',
+                              f'osnr: {x["osnr"]:7.2f}',
+                              f'power: {x["power"]:7.2f}', ])
+                for x in channels)
+            print(f'{u.id:^10s} → {v.id:^10s} {channel_info}')
diff --git a/gnpy/network_elements.py b/gnpy/network_elements.py
index 800e818..480e7bb 100644
--- a/gnpy/network_elements.py
+++ b/gnpy/network_elements.py
@@ -1,142 +1,125 @@
-import networkx as nx
-from .utils import Utils
-import gnpy
-
-
-class Params:
-
-    def __init__(self, *args):
-        req_params = args[0]
-        params = args[1].get('parameters')
-        missing_params = list(set(req_params) - set(params.keys()))
-        if len(missing_params):
-            print("missing params:", ','.join(missing_params))
-            raise ValueError
-        for k, v in params.items():
-            setattr(self, k, v)
+from networkx import DiGraph, all_simple_paths
+from collections import defaultdict
+from itertools import product
 
+import gnpy
+from . import utils
 
 class Opath:
-
     def __init__(self, nw, path):
-        self.nw = nw
-        self.path = path
-        self.edge_list = [(elem, path[en + 1])
-                          for en, elem in enumerate(path[:-1])]
-        self.elem_dict = {elem: self.find_io_edges(elem)
-                          for elem in self.path}
+        self.nw, self.path = nw, path
+        self.edge_list = {(elem, path[en + 1]) for en, elem in enumerate(path[:-1])}
+        self.elem_dict = {elem: self.find_io_edges(elem) for elem in self.path}
 
     def find_io_edges(self, elem):
-        iedges = set(self.nw.g.in_edges(elem)).intersection(self.edge_list)
-        oedges = set(self.nw.g.out_edges(elem)).intersection(self.edge_list)
-        return {'in': list(iedges),
-                'out': list(oedges)}
+        iedges = set(self.nw.g.in_edges(elem) ) & self.edge_list
+        oedges = set(self.nw.g.out_edges(elem)) & self.edge_list
+        return {'in': iedges, 'out': oedges}
 
     def propagate(self):
         for elem in self.path:
             elem.propagate(path=self)
 
-
 class Network:
-
-    g = nx.DiGraph()
-    nw_elems = {}
-
-    def __init__(self, network_config):
-        self.config = Utils.read_config(network_config)
+    def __init__(self, config):
+        self.config = config
+        self.nw_elems = defaultdict(list)
+        self.g = DiGraph()
         for elem in self.config['elements']:
-            ne_type = elem['type'].capitalize()
-            if ne_type not in self.nw_elems:
-                self.nw_elems[ne_type] = []
-            ne = getattr(gnpy, ne_type)(self, **elem)
+            ne_type = TYPE_MAP[elem['type']]
+            params = elem.pop('parameters')
+            ne = ne_type(self, **elem, **params)
             self.nw_elems[ne_type].append(ne)
             self.g.add_node(ne)
 
         for gpath in self.config['topology']:
-            n0 = Utils.find_by_node_id(self.g, gpath[0])
-            for nid in gpath[1:]:
-                n1 = Utils.find_by_node_id(self.g, nid)
+            for u, v in utils.nwise(gpath):
+                n0 = utils.find_by_node_id(self.g, u)
+                n1 = utils.find_by_node_id(self.g, v)
                 self.g.add_edge(n0, n1, channels=[])
-                n0 = n1
 
         # define all possible paths between tx's and rx's
         self.tr_paths = []
-        for tx in self.nw_elems['Tx']:
-            for rx in self.nw_elems['Rx']:
-                for spath in nx.all_simple_paths(self.g, tx, rx):
-                    self.tr_paths.append(Opath(self, spath))
+        for tx, rx in product(self.nw_elems[Tx], self.nw_elems[Rx]):
+            for spath in all_simple_paths(self.g, tx, rx):
+                self.tr_paths.append(Opath(self, spath))
 
     def propagate_all_paths(self):
         for opath in self.tr_paths:
             opath.propagate()
 
-
 class NetworkElement:
-
-    def __init__(self, nw, **kwargs):
+    def __init__(self, nw, *, id, type, name, description, **kwargs):
         self.nw = nw
-        self.id = kwargs.get('id')
-        self.type = kwargs.get('type')
-        self.name = kwargs.get('name')
-        self.description = kwargs.get('description')
-        self.params = Params(self.required_params, kwargs)
+        self.id, self.type, self.name, self.description = id, type, name, description
 
     def fetch_edge(self, edge):
-        return self.nw.g[edge[0]][edge[1]]
+        u, v = edge
+        return self.nw.g[u][v]
 
     def edge_dict(self, chan, osnr, d_power):
-        dct = {'frequency': chan['frequency'],
-               'osnr': osnr if osnr else chan['osnr'],
-               'power': chan['power'] + d_power}
-        return dct
+        return {'frequency': chan['frequency'],
+                'osnr':      osnr if osnr else chan['osnr'],
+                'power':     chan['power'] + d_power}
 
     def __repr__(self):
-        return self.id
-
+        return f'NetworkElement(id={self.id}, type={self.type})'
 
 class Fiber(NetworkElement):
-    required_params = ['length', 'loss']
+    def __init__(self, *args, length, loss, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.length = length
+        self.loss = loss
 
     def propagate(self, path):
-        attn = self.params.length * self.params.loss
+        attn = self.length * self.loss
         for oedge in path.elem_dict[self]['out']:
             edge = self.fetch_edge(oedge)
-            for inedge in path.elem_dict[self]['in']:
-                pedge = self.fetch_edge(inedge)
+            for pedge in (self.fetch_edge(x) for x in path.elem_dict[self]['in']):
                 for chan in pedge['channels']:
                     edge['channels'].append(self.edge_dict(chan, None, -attn))
 
-
 class Edfa(NetworkElement):
-    required_params = ['gain', 'nf']
+    def __init__(self, *args, gain, nf, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.gain = gain
+        self.nf = nf
 
     def propagate(self, path):
-        gain = self.params.gain[0]
+        gain = self.gain[0]
         for inedge in path.elem_dict[self]['in']:
             in_channels = self.fetch_edge(inedge)['channels']
             for chan in in_channels:
-                osnr = Utils.chan_osnr(chan, self.params)
+                osnr = utils.chan_osnr(chan, self)
                 for oedge in path.elem_dict[self]['out']:
                     edge = self.fetch_edge(oedge)
                     edge['channels'].append(self.edge_dict(chan, osnr, gain))
 
-
 class Tx(NetworkElement):
-    required_params = ['channels']
+    def __init__(self, *args, channels, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.channels = channels
 
     def propagate(self, path):
-        for oedge in path.elem_dict[self]['out']:
-            edge = self.fetch_edge(oedge)
-            for chan in self.params.channels:
+        for edge in (self.fetch_edge(x) for x in path.elem_dict[self]['out']):
+            for chan in self.channels:
                 edge['channels'].append(self.edge_dict(chan, None, 0))
 
-
 class Rx(NetworkElement):
-    required_params = ['sensitivity']
-    channels = {}
+    def __init__(self, *args, sensitivity, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.sensitivity = sensitivity
 
     def propagate(self, path):
         self.channels = {}
         for iedge in path.elem_dict[self]['in']:
             edge = self.fetch_edge(iedge)
             self.channels[path] = edge['channels']
+
+TYPE_MAP = {
+    'fiber': Fiber,
+    'tx':    Tx,
+    'rx':    Rx,
+    'edfa':  Edfa,
+}
+
diff --git a/gnpy/utils.py b/gnpy/utils.py
index c26838d..5ec9cac 100644
--- a/gnpy/utils.py
+++ b/gnpy/utils.py
@@ -1,46 +1,37 @@
 import json
 from gnpy.constants import c, h
 import numpy as np
+from itertools import tee, islice
 
+nwise = lambda g, n=2: zip(*(islice(g, i, None) for i, g in enumerate(tee(g, n))))
 
-class Utils:
+def read_config(filepath):
+    with open(filepath, 'r') as f:
+        return json.load(f)
 
-    @staticmethod
-    def read_config(filepath):
-        try:
-            with open(filepath, 'r') as f:
-                config = json.load(f)
-            return config
-        except FileNotFoundError:
-            print("File not found:", filepath)
+def find_by_node_id(g, nid):
+    # ?ODO: What if nid is not found in graph (g)?
+    return next(n for n in g.nodes() if n.id == nid)
 
-    @staticmethod
-    def find_by_node_id(g, nid):
-        # ?ODO: What if nid is not found in graph (g)?
-        return next((n for n in g.nodes() if n.id == nid), None)
+def dbkm_2_lin(loss_coef):
+    """ calculates the linear loss coefficient
+    """
+    alpha_pcoef = loss_coef
+    alpha_acoef = alpha_pcoef/(2*4.3429448190325184)
+    s = 'alpha_pcoef is linear loss coefficient in [dB/km^-1] units'
+    s = ''.join([s, "alpha_acoef is linear loss field amplitude \
+                 coefficient in [km^-1] units"])
+    d = {'alpha_pcoef': alpha_pcoef, 'alpha_acoef': alpha_acoef,
+         'description:': s}
+    return d
 
-    @staticmethod
-    def dbkm_2_lin(loss_coef):
-        """ calculates the linear loss coefficient
-        """
-        alpha_pcoef = loss_coef
-        alpha_acoef = alpha_pcoef/(2*4.3429448190325184)
-        s = 'alpha_pcoef is linear loss coefficient in [dB/km^-1] units'
-        s = ''.join([s, "alpha_acoef is linear loss field amplitude \
-                     coefficient in [km^-1] units"])
-        d = {'alpha_pcoef': alpha_pcoef, 'alpha_acoef': alpha_acoef,
-             'description:': s}
-        return d
+def db_to_lin(val):
+    return 10 ** (val / 10)
 
-    @staticmethod
-    def db_to_lin(val):
-        return 10 ** (val / 10)
-
-    @staticmethod
-    def chan_osnr(chan_params, amp_params):
-        in_osnr = Utils.db_to_lin(chan_params['osnr'])
-        pin = Utils.db_to_lin(chan_params['power']) / 1e3
-        nf = Utils.db_to_lin(amp_params.nf[0])
-        ase_cont = nf * h * chan_params['frequency'] * 12.5 * 1e21
-        ret = -10 * np.log10(1 / in_osnr + ase_cont / pin)
-        return ret
+def chan_osnr(chan_params, amp_params):
+    in_osnr = db_to_lin(chan_params['osnr'])
+    pin = db_to_lin(chan_params['power']) / 1e3
+    nf = db_to_lin(amp_params.nf[0])
+    ase_cont = nf * h * chan_params['frequency'] * 12.5 * 1e21
+    ret = -10 * np.log10(1 / in_osnr + ase_cont / pin)
+    return ret
